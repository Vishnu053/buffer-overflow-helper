<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BuffTools</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <style>
        /* Dark mode styles */
        [data-bs-theme="dark"] {
            color-scheme: dark;
            --bs-body-color: #dee2e6;
            --bs-body-bg: #212529;
        }
        .copy-btn {
            position: absolute;
            right: 10px;
            top: 10px;
            z-index: 100;
        }
        .output-container {
            position: relative;
        }
        /* Add smooth transitions for dark mode */
        body {
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        /* Tooltip styles */
        .custom-tooltip {
            position: relative;
            display: inline-block;
        }
        .custom-tooltip .tooltip-text {
            visibility: hidden;
            background-color: rgba(0,0,0,0.8);
            color: #fff;
            text-align: center;
            padding: 5px;
            border-radius: 6px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        .custom-tooltip:hover .tooltip-text {
            visibility: visible;
        }
        /* Toast notification styles */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        .toast-notification {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            margin: 5px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .toast-notification.show {
            opacity: 1;
        }
        /* Quick nav styles */
        .quick-nav {
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.5rem;
            background: var(--bs-body-bg);
            border: 1px solid var(--bs-border-color);
        }
        .quick-nav-title {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--bs-primary);
        }
        .quick-nav-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .quick-nav-link {
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.875rem;
            color: var(--bs-body-color);
            background: var(--bs-secondary-bg);
            text-decoration: none;
            transition: all 0.2s ease;
        }
        .quick-nav-link:hover {
            background: var(--bs-primary);
            color: white;
        }
    </style>
</head>

<body :data-bs-theme="darkMode ? 'dark' : 'light'">
    <!-- Toast container -->
    <div class="toast-container" ref="toastContainer"></div>
    
    <div id="report" class="mt-2">
        <!-- Header with dark mode toggle -->
        <div class="sticky-top bg-body py-2 border-bottom">
            <div class="container-fluid d-flex justify-content-between align-items-center">
                <nav class="nav nav-pills flex-grow-1 mx-2">
                    <a v-for="(type,i) in links" 
                       :key="'type'+i" 
                       :class="type.active ? 'nav-link active' : 'nav-link'"
                       href="#" 
                       @click="filterByType(type)">{{type.name}}</a>
                </nav>
                <button class="btn btn-outline-primary me-2" @click="toggleDarkMode">
                    <i :class="darkMode ? 'bi bi-sun' : 'bi bi-moon'"></i>
                </button>
            </div>
        </div>

        <div class="container-fluid mt-3">
            <!-- Buffer Overflow Tools -->
            <div v-if="filteredType=='buffOvf'" class="row">
                <!-- Quick Navigation -->
                <div class="col-12 mb-4">
                    <div class="quick-nav">
                        <div class="quick-nav-title">Quick Navigation</div>
                        <div class="quick-nav-items">
                            <a href="#pattern-generator" class="quick-nav-link">Pattern Generator</a>
                            <a href="#badchars-generator" class="quick-nav-link">BadChars Generator</a>
                            <a href="#little-endian" class="quick-nav-link">Little Endian Converter</a>
                        </div>
                    </div>
                </div>

                <!-- Pattern Generator -->
                <div id="pattern-generator" class="col-12 mb-4">
                    <div class="card">
                        <div class="card-header">
                            <h3 class="mb-0">Pattern Generator</h3>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label custom-tooltip">
                                    Character
                                    <span class="tooltip-text">Character to repeat in pattern</span>
                                </label>
                                <input class="form-control" type="text" v-model="charToGenerate">
                            </div>
                            <div class="mb-3">
                                <label class="form-label custom-tooltip">
                                    Length
                                    <span class="tooltip-text">Number of times to repeat the character</span>
                                </label>
                                <input class="form-control" type="number" v-model="charLengthToGenerate">
                            </div>
                            <div class="mb-3">
                                <button class="btn btn-primary" @click="generatePattern">
                                    <i class="bi bi-lightning-charge"></i> Generate Pattern
                                </button>
                            </div>
                            <div class="mb-3 output-container">
                                <label class="form-label">Generated Pattern</label>
                                <button class="btn btn-sm btn-outline-primary copy-btn" 
                                        @click="copyToClipboard(generatedChars)">
                                    <i class="bi bi-clipboard"></i>
                                </button>
                                <textarea class="form-control" v-model="generatedChars" rows="5" readonly></textarea>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- BadChars Generator -->
                <div id="badchars-generator" class="col-12 mb-4">
                    <div class="card">
                        <div class="card-header">
                            <h3 class="mb-0">BadChars Generator</h3>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label custom-tooltip">
                                    Length
                                    <span class="tooltip-text">Length of bad characters to generate</span>
                                </label>
                                <input class="form-control" type="number" v-model="generateBadCharsLength">
                            </div>
                            <div class="mb-3">
                                <button class="btn btn-primary" @click="generateBadChars">
                                    <i class="bi bi-lightning-charge"></i> Generate Bad Chars
                                </button>
                            </div>
                            <div class="mb-3 output-container">
                                <label class="form-label">Payload</label>
                                <button class="btn btn-sm btn-outline-primary copy-btn" 
                                        @click="copyToClipboard(payload)">
                                    <i class="bi bi-clipboard"></i>
                                </button>
                                <textarea class="form-control" v-model="payload" rows="5"></textarea>
                            </div>
                            <div class="mb-3">
                                <label class="form-label custom-tooltip">
                                    Bad Characters
                                    <span class="tooltip-text">Characters to exclude from payload</span>
                                </label>
                                <input class="form-control" type="text" v-model="badChars" 
                                       >
                            </div>
                            <div class="mb-3">
                                <button class="btn btn-primary" @click="generateNewPayload">
                                    <i class="bi bi-lightning-charge"></i> Generate New Payload
                                </button>
                            </div>
                            <div class="mb-3 output-container">
                                <label class="form-label">New Payload</label>
                                <button class="btn btn-sm btn-outline-primary copy-btn" 
                                        @click="copyToClipboard(newPayload)">
                                    <i class="bi bi-clipboard"></i>
                                </button>
                                <textarea class="form-control" v-model="newPayload" rows="5" readonly></textarea>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Little Endian Converter -->
                <div id="little-endian" class="col-12 mb-4">
                    <div class="card">
                        <div class="card-header">
                            <h3 class="mb-0">Little Endian Converter</h3>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label custom-tooltip">
                                    Input Value
                                    <span class="tooltip-text">Hex value to convert to little endian</span>
                                </label>
                                <input class="form-control" type="text" v-model="littleEndianInput">
                            </div>
                            <div class="mb-3">
                                <button class="btn btn-primary" @click="generateLittleEndian">
                                    <i class="bi bi-lightning-charge"></i> Generate Little Endian
                                </button>
                            </div>
                            <div class="mb-3 output-container">
                                <label class="form-label">Little Endian Result</label>
                                <button class="btn btn-sm btn-outline-primary copy-btn" 
                                        @click="copyToClipboard(generatedLittleEndian)">
                                    <i class="bi bi-clipboard"></i>
                                </button>
                                <textarea class="form-control" v-model="generatedLittleEndian" rows="5" readonly></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hash Tools -->
            <div v-if="filteredType=='hashes'" class="row">
                <!-- Quick Navigation -->
                <div class="col-12 mb-4">
                    <div class="quick-nav">
                        <div class="quick-nav-title">Quick Navigation</div>
                        <div class="quick-nav-items">
                            <a v-for="hash in hashes" 
                               :key="hash.functionToExecute"
                               :href="'#' + hash.functionToExecute" 
                               class="quick-nav-link">
                                {{hash.title}}
                            </a>
                        </div>
                    </div>
                </div>

                <div v-for="(hash,i) in hashes" 
                     :key="'hash'+i" 
                     :id="hash.functionToExecute"
                     class="col-12 mb-4">
                    <div class="card">
                        <div class="card-header">
                            <h3 class="mb-0">{{hash.title}}</h3>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label">{{hash.label}}</label>
                                <textarea class="form-control" v-model="hash.inputmodel" rows="5"
                                    @input="onHashInput(hash.functionToExecute,hash.inputmodel,i)"></textarea>
                            </div>
                            <div class="mb-3 output-container">
                                <label class="form-label">Result</label>
                                <button class="btn btn-sm btn-outline-primary copy-btn" 
                                        @click="copyToClipboard(hash.outputmodel)">
                                    <i class="bi bi-clipboard"></i>
                                </button>
                                <textarea class="form-control" v-model="hash.outputmodel" rows="5" readonly></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Crypto Tools (Coming Soon) -->
            <div v-if="filteredType=='crypto'" class="row">
                <div class="col-12 text-center">
                    <div class="card">
                        <div class="card-body">
                            <h3>Crypto Tools</h3>
                            <p class="text-muted">Coming Soon! Stay tuned for encryption and decryption tools.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, watch } = Vue

        const app = createApp({
            data() {
                return {
                    darkMode: localStorage.getItem('darkMode') === 'true' || false,
                    links: [{
                        name: "Buff. Overflow",
                        active: true,
                        type: "buffOvf"
                    }, {
                        name: "Hashes",
                        active: false,
                        type: "hashes"
                    }, {
                        name: "Crypto",
                        active: false,
                        type: "crypto"
                    }],
                    filteredType: "buffOvf",
                    charToGenerate: "A",
                    charLengthToGenerate: 2000,
                    generatedChars: "",
                    generateBadCharsLength: 256,
                    generatedBadChars: "",
                    payload: "",
                    badChars: "",
                    newPayload: "",
                    littleEndianInput: "",
                    generatedLittleEndian: "",
                    hashes: [
                        {
                            title: "Base64 Encoder",
                            label: "Enter text to encode",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "base64enc"
                        },
                        {
                            title: "Base64 Decoder",
                            label: "Enter base64 to decode",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "base64dec"
                        },
                        {
                            title: "MD5 Hash",
                            label: "Enter text to hash",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "md5"
                        },
                        {
                            title: "SHA1 Hash",
                            label: "Enter text to hash",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "sha1"
                        },
                        {
                            title: "SHA3 Hash",
                            label: "Enter text to hash",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "sha3"
                        },
                        {
                            title: "SHA224 Hash",
                            label: "Enter text to hash",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "sha224"
                        },
                        {
                            title: "SHA256 Hash",
                            label: "Enter text to hash",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "sha256"
                        },
                        {
                            title: "SHA384 Hash",
                            label: "Enter text to hash",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "sha384"
                        },
                        {
                            title: "SHA512 Hash",
                            label: "Enter text to hash",
                            inputmodel: "",
                            outputmodel: "",
                            functionToExecute: "sha512"
                        }
                    ]
                }
            },
            methods: {
                // UI Methods
                toggleDarkMode() {
                    this.darkMode = !this.darkMode;
                    localStorage.setItem('darkMode', this.darkMode);
                },
                async copyToClipboard(text) {
                    try {
                        await navigator.clipboard.writeText(text);
                        this.showToast('Copied to clipboard!');
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                        this.showToast('Failed to copy text', true);
                    }
                },
                filterByType(type) {
                    this.links.forEach(link => link.active = false);
                    type.active = true;
                    this.filteredType = type.type;
                },

                // Buffer Overflow Tools
                generateBadChars() {
                    if (!this.generateBadCharsLength || this.generateBadCharsLength <= 0) {
                        this.showToast('Please enter a valid length', true);
                        return;
                    }
                    let result = '';
                    for (let i = 1; i <= this.generateBadCharsLength; i++) {
                        result += String.fromCharCode(i - 1);
                    }
                    this.payload = result;
                    this.showToast('Bad chars generated successfully!');
                },
                generateNewPayload() {
                    if (!this.payload || !this.badChars) {
                        this.showToast('Please provide both payload and bad chars', true);
                        return;
                    }
                    
                    const badCharsSet = new Set(this.badChars.split(''));
                    this.newPayload = this.payload
                        .split('')
                        .filter(char => !badCharsSet.has(char))
                        .join('');
                    this.showToast('New payload generated successfully!');
                },

                // Hash Functions
                onHashInput(func, input, index) {
                    if (!input) {
                        this.hashes[index].outputmodel = '';
                        return;
                    }

                    try {
                        switch(func) {
                            case 'base64enc':
                                this.hashes[index].outputmodel = btoa(input);
                                break;
                            case 'base64dec':
                                this.hashes[index].outputmodel = atob(input);
                                break;
                            case 'md5':
                                this.hashes[index].outputmodel = CryptoJS.MD5(input).toString();
                                break;
                            case 'sha1':
                                this.hashes[index].outputmodel = CryptoJS.SHA1(input).toString();
                                break;
                            case 'sha3':
                                this.hashes[index].outputmodel = CryptoJS.SHA3(input).toString();
                                break;
                            case 'sha224':
                                this.hashes[index].outputmodel = CryptoJS.SHA224(input).toString();
                                break;
                            case 'sha256':
                                this.hashes[index].outputmodel = CryptoJS.SHA256(input).toString();
                                break;
                            case 'sha384':
                                this.hashes[index].outputmodel = CryptoJS.SHA384(input).toString();
                                break;
                            case 'sha512':
                                this.hashes[index].outputmodel = CryptoJS.SHA512(input).toString();
                                break;
                        }
                    } catch (error) {
                        this.hashes[index].outputmodel = 'Error: Invalid input';
                        console.error('Hash generation error:', error);
                    }
                },
                showToast(message, isError = false) {
                    if (this.$refs.toastContainer) {
                        const toast = document.createElement('div');
                        toast.className = 'toast-notification';
                        toast.textContent = message;
                        if (isError) {
                            toast.style.backgroundColor = 'rgba(220, 53, 69, 0.9)'; // Bootstrap danger color
                        }
                        this.$refs.toastContainer.appendChild(toast);
                        
                        // Trigger reflow to enable transition
                        toast.offsetHeight;
                        toast.classList.add('show');
                        
                        setTimeout(() => {
                            toast.classList.remove('show');
                            setTimeout(() => {
                                if (toast.parentNode) {  // Check if toast still exists
                                    toast.remove();
                                }
                            }, 300); // Wait for fade out transition
                        }, 2000); // Show for 2 seconds
                    }
                },
                generatePattern() {
                    if (!this.charToGenerate) {
                        this.showToast('Please enter a character', true);
                        return;
                    }
                    try {
                        this.generatedChars = this.charToGenerate.repeat(this.charLengthToGenerate);
                        this.showToast('Pattern generated successfully!');
                    } catch (error) {
                        this.generatedChars = "Error: Invalid input";
                        this.showToast('Failed to generate pattern', true);
                        console.error('Character generation error:', error);
                    }
                },
                generateLittleEndian() {
                    if (!this.littleEndianInput) {
                        this.showToast('Please enter a hex value', true);
                        return;
                    }
                    try {
                        const b = this.littleEndianInput.match(/.{1,2}/g);
                        if (b) {
                            this.generatedLittleEndian = "\\x" + b.reverse().join('\\x');
                            this.showToast('Little endian conversion successful!');
                        } else {
                            this.generatedLittleEndian = "Error: Invalid input format";
                            this.showToast('Invalid hex format', true);
                        }
                    } catch (error) {
                        this.generatedLittleEndian = "Error: Invalid input";
                        this.showToast('Failed to convert to little endian', true);
                        console.error('Little endian conversion error:', error);
                    }
                }
            },
            watch: {
                charToGenerate() {
                    if (this.charLengthToGenerate) {
                        this.generatedChars = this.charToGenerate.repeat(this.charLengthToGenerate);
                    }
                }
            }
        })

        app.mount('#report')
    </script>
</body>

</html>
